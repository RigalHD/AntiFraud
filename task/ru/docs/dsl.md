# DSL: уровни поддержки, выполнение, проверка

Этот документ описывает правила мини-языка (DSL).

## Контекст вычисления правила (RuleEvaluationContext)

Правило считается по входным данным:

- `transaction` (входные поля транзакции).
- `user` (профиль пользователя).

Это не требование к конкретному классу/типу в коде. Смысл простой: вычисление DSL не должно зависеть от общего состояния
приложения и не должно менять данные в системе.

## Уровни поддержки DSL (Tier)

Уровень N включает все, что было на уровнях ниже.

### Уровень 0 (Tier 0) — разрешенный старт

Это режим, в котором вы **еще не разбираете** DSL и не вычисляете выражения.

Правила уровня 0:

- `POST /fraud-rules/validate` возвращает `isValid=false` для любого `dslExpression`.
- При применении правил в транзакциях сервис не падает, а каждое правило считается `matched=false` (с непустым
  `ruleResults[].description`).

Уровень 0 нужен, чтобы можно было начать с API/БД/транзакций и воспроизводимости, а парсер добавить позже.

### Уровень 1 (обязательный минимум)

- Поля: `amount`.
- Операторы: `> >= < <= = !=`.
- Литералы: `number`.
- Выражение: одно `comparison` без `AND/OR/NOT/()`.

### Уровень 2

- Поля: `currency`, `merchantId`, `ipAddress`, `deviceId`.
- Литералы: `string` в одинарных кавычках (`'RUB'`).
- Для строк допустимы только `=` и `!=` (иначе `DSL_INVALID_OPERATOR`).

### Уровень 3

- Логика: `AND`, `OR` (регистронезависимы).
- Приоритет: `AND` выше `OR`.

### Уровень 4

- `NOT` и скобки `(...)`.
- Приоритет: `NOT > AND > OR`.

### Уровень 5

- Поля пользователя: `user.age`, `user.region`.
- Семантика null: если поле пользователя `null` → соответствующее сравнение возвращает `false`.

## Не упрощайте выражения

Проверка и вычисление DSL **не должны** пытаться умно упрощать выражения.
Пример: `amount > 10 000 AND amount < 5 000`:

- должно валидироваться как корректное выражение;
- при применении должно возвращать `matched=false`;
- сервис не должен падать.

## Грамматика (EBNF)

```
expression = term { "OR" term }
term       = factor { "AND" factor }
factor     = "NOT" factor | comparison | "(" expression ")"
comparison = field operator value
field      = "amount" | "currency" | "merchantId" | "ipAddress" | "deviceId"
           | "user.age" | "user.region"
operator   = ">" | ">=" | "<" | "<=" | "=" | "!="
value      = number | string
string     = "'" { character } "'"
number     = digit { digit } [ "." digit { digit } ]
```

## Как применять правила к транзакции (runtime)

- При создании транзакции сервис обязан применить **все** активные правила (`enabled=true`).
- Порядок правил обязан быть воспроизводимым: `priority ASC`, затем `id ASC`.
- Результаты должны быть посчитаны для каждого правила, а `ruleResults` обязан содержать все правила в указанном
  порядке.
- `GET /transactions/{id}` возвращает сохраненные `ruleResults` и не пересчитывает их.

### Если правило нельзя посчитать, сервис все равно живет.

Если правило нельзя вычислить (например, используется неподдерживаемый уровень, выражение слишком сложное или произошла
ошибка вычисления), сервис обязан:

- не падать и не возвращать 5xx из-за одного правила;
- считать результат этого правила как `matched=false`;
- вернуть элемент `ruleResults` для этого правила;
- заполнить `ruleResults.description` человекочитаемым объяснением (содержание не сравнивается, проверяется только
  наличие).

## Проверка DSL (validator)

### Где проверяется

- `POST /fraud-rules/validate` — проверка без сохранения (всегда `200`, результат в `isValid`).
- `POST /fraud-rules`, `PUT /fraud-rules/{id}` — создают/обновляют правило и сохраняют `dslExpression` как строку;
  проверка DSL делается отдельным вызовом `/fraud-rules/validate`.

### Коды ошибок (машиночитаемые)

- `DSL_PARSE_ERROR` — синтаксическая ошибка (для этого кода `position` и `near` обязательны, но тест-системой будет проверяться только их наличие).
- `DSL_INVALID_FIELD` — неизвестное поле DSL.
- `DSL_INVALID_OPERATOR` — оператор неприменим к типу значения (например, `currency > 'RUB'`).

### Нормализация

- `AND/OR/NOT` приводятся к верхнему регистру.
- Вокруг бинарных операторов — один пробел: `amount>10` → `amount > 10`.
- Убираются лишние скобки: `((amount > 100))` → `amount > 100`.
- Убираются скобки, не влияющие на логику: `(a AND b) AND c` → `a AND b AND c`.

