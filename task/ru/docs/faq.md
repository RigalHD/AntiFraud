# FAQ

## Какой язык программирования использовать?

Любой. Главное, чтобы сервис запускался в Docker и отвечал по API так, как описано в `../openapi.yml`.

## Почему `POST /transactions` возвращает 201 даже при DECLINED?

Потому что транзакция создается и сохраняется как ресурс. `DECLINED` — бизнес-результат антифрода и отражается в
`status/isFraud`, а не в HTTP-коде.

## Что такое воспроизводимость в рамках задания?

Если правила те же, запрос тот же и база данных не менялась, ответ должен быть тем же.  
Автопроверка сравнивает ответ «по смыслу» и обычно игнорирует только `id` и временные поля.

## Нужен ли refreshToken?

Нет. В задании достаточно одного JWT-токена.

## Как отличить «Поле не передано» от «Поле = null» в PUT?

- Ключ отсутствует в JSON: это ошибка валидации → `422`.
- Ключ присутствует и значение `null`: это явная команда «Очистить поле» (допустимо только для nullable-полей).

## Можно ли изменить email пользователя?

Нет. Email менять нельзя. Если клиент все же пришлет `email` в `PUT /users/*`, сервис должен его игнорировать.

## Может ли ADMIN деактивировать сам себя?

Да. ADMIN может деактивировать любого пользователя, включая себя (`DELETE /users/{id}` ставит `isActive=false`).
После деактивации этот пользователь не сможет войти (логин вернет `423`).

## Как трактуется `userId` в транзакциях для USER?

Для роли USER фактический `userId` всегда берется из JWT (`sub`). Поле `userId` в теле запроса игнорируется (даже если
передано).

## Должен ли сервис проверять все правила или можно остановиться на первом совпадении?

Нужно проверять все активные правила. Останавливаться на первом совпадении нельзя, потому что `ruleResults` сохраняется
в базе и должен быть полным.

## Что, если правило нельзя вычислить (неподдерживаемый уровень / слишком сложное / ошибка вычисления)?

Сервис не должен падать из-за одного правила. Такое правило считается `matched=false`, обработка продолжается, а
`ruleResults[].description` должен быть заполнен.

## Можно ли использовать библиотеки для парсинга DSL?

Да. Можно использовать любые библиотеки. Главное — соблюдать поведение, описанное в `./dsl.md` и `../openapi.yml`.

## Можно ли сдать без парсера DSL?

Да. На первом этапе допускается уровень поддержки 0 (Tier 0): `/fraud-rules/validate` возвращает `isValid=false`,
а при применении правил все правила считаются `matched=false`. Это позволяет набрать первые баллы на
API/БД/воспроизводимости, а затем добавлять уровни поддержки.

## Что делать, если DSL-выражение некорректное?

Проверяйте выражение через `POST /fraud-rules/validate`.  
При создании/обновлении правила сервис не обязан парсить DSL и не должен возвращать `422` “за DSL”.

## Обязательное ли поле `ruleResults[].description`?

Да, обязательное и непустое. Это требование описано в `../openapi.yml` (и его проверяет автопроверка).

## Параметры `position` и `near` в ошибках DSL обязательные?

Они обязательны только для ошибки `DSL_PARSE_ERROR`. Для остальных ошибок DSL эти поля могут отсутствовать или быть
`null`.

## Что, если нет активных правил антифрода?

Транзакция должна быть одобрена: `status=APPROVED`, `isFraud=false`.  
`ruleResults` при этом будет пустым массивом.

## Можно ли создать транзакцию для деактивированного пользователя?

Нет. Вернется `403 Forbidden`.

## Что, если timestamp-транзакции в далеком прошлом?

Это нормально. Ограничение только на слишком далекое будущее: `timestamp` не должен быть больше чем `now + 5 минут` (
иначе `422`).

## Что, если передать пустой массив `items` в батч-запросе?

Вернется `422`: массив должен содержать от 1 до 500 элементов.

## Что, если правило проверяет `user.age`, а у пользователя возраст не указан?

Такое сравнение должно дать `false`, то есть правило не сработает. Это правило описано в `./dsl.md`.

## Как сортируются правила при одинаковом `priority`?

По `priority` по возрастанию, а если одинаково — по `id` по возрастанию.

## Почему для timeseries с `groupBy=week` разрешен период до года?

Это исключение из общего лимита 90 дней: при группировке по неделям точек меньше, поэтому разрешен период до 1 года.

## Поле `uniqueMerchants` в статистике правил обязательное?

Нет. Это опциональное поле, его может не быть в ответе.

## Что, если клиент прислал лишние поля в JSON?

Ориентируйтесь на поля из `../openapi.yml`. Лишние поля лучше игнорировать и не ронять запрос только из‑за них (если это
не ломает вашу валидацию).

## Какие поля в объекте User могут отсутствовать?

Опциональные поля профиля могут быть `null`: `age`, `region`, `gender`, `maritalStatus`.  
Обязательные поля в ответе — см. `../openapi.yml` (схема `User`).

## Какие поля в объекте Transaction могут отсутствовать?

Опциональные поля могут отсутствовать или быть пустыми: `merchantId`, `merchantCategoryCode`, `ipAddress`, `deviceId`,
`channel`, `location`, `metadata`.  
Обязательные поля в ответе — см. `../openapi.yml` (схема `Transaction`).

